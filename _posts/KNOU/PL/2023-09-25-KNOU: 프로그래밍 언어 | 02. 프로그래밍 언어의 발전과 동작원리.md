---
date : YYYY-MM-DD HH:MM:SS +09:00
categories: [KNOU, PL]
tags: [PL]
published: true
---


# 프로그래밍 언어의 발전

## 컴퓨터 시스템의 발전
### 아이디어 시대
계산 자동화를 위한 상상속 기계 설계 (튜링 기계)

### 전자식 컴퓨터의 등장
전자 신호를 통한 계산 기계 (에니악, 콜로서스)

### 프로그램 저장 방식의 컴퓨터
프로그램과 처리기를 분리 (에드박)


## 운영체제의 발전
### 일괄 처리 운영체제 
관리자(사람)를 대신할 프로그램 등장 (들어온 순서대로만 처리 가능)

### 시분할 운영체제
한 컴퓨터를 여러 사람이 사용 (거의 동시에 작업하는 것처럼 보임)

### DOS
IBM, Apple 등 개인용 컴퓨터 (PC)

### PC 환경 운영체제 발전
GUI 운영체제와 Linux 의 발전


## 초기 프로그래밍 언어 (1950년대)
이전에는 기계어를 사용했지만
최초의 고급 언어로 볼 수 있다
- Fortran: 수식과 문장, 제어문의 등장 
IBM 의 존 배커스에 의해 개발됨
과학 계산용 언어

- Algol: 구조화 프로그래밍의 발전
본래 이름: IAL
국제 위원회 ACM-GAMM 을 통해 설계된 언어
알고리즘을 기술하는 언어

문제를 해결하기 위한 코드 흐름을 순차적으로만 하는 것이 아니라 
구조화하여 알고리즘을 풀어낼 수 있다

- LISP: 최초의 함수형 언어
MIT의 존 매카시가 설계
프로그램과 데이터의 형태가 동일하다 -> 프로그램을 데이터로 받을 수 있다 (초기 인공지능 분야에서 자주 사용)

## 프로그래밍 언어의 발전 (1960년대)
- Cobol: 레코드 타입의 소개
미 해군에서 그레이스 호퍼가 사무용 언어로 개발함

- PL/1: 모든 언어를 합쳐서 만들어보았으나 너무 복잡해졌다

- BASIC: 교육용 언어

- Simula: 객체지향의 등장
  시뮬레이션 언어


## 프로그래밍 언어의 단순화 (1970년대)
- Pascal: 차세대 교육용 언어
구조화 프로그래밍을 지원한다

- C: 진정한 시스템 프로그래밍 언어
Unix 개발용 시스템 프로그래밍 언어로 Java, C++ 등 다양한 언어에 지대한 영향을 끼쳤다
최근 사용되는 대부분의 다른 언어들은 응용 프로그래밍 언어
시스템 프로그래밍 언어라 함은 하드웨어와 사용자를 연결해주는 목적의 프로그래밍을 할 수 있는 언어

- Prolog: 선언적 논리 언어
최초의 논리 언어

- Smalltalk: 객체지향 언어의 발전 (데이터 자체가 객체)
최초로 GUI, 마우스 등을 도입

- Ada: 안정성을 위한 매우 복잡한 언어
미 국방성의 공모로 만들어짐

- ML: 타입 시스템을 갖춘 현대 프로그래밍 언어
강력한 정적 타입 검사, 타입 추론, 패턴 검사, 예외 처리 등

- Scheme: 간결한 LISP 로 MTI 학생들의 기초 프로그래밍 언어

## 현대 프로그래밍 언어의 등장 (1980년대)
- Common Lisp: 방대한 LISP 의 통합
멀티 패러다임 언어

- Objective-C: C의 탈을 쓴 Smalltalk
C 를 기초로 한 객체지향 언어의 신호탄
Apple 사의 애플리케이션 작성 언어로 발전

- C++: 객체지향을 도입한 C
객체지향, 클래스 개념을 C에 도입

- Perl: 문자열 처리를 위한 언어 (정규식 기반)

## 프로그래밍 언어의 대중화 (1990년대 이후)
- Java: 단순한 객체지향 언어
원래 목적은 임베디드 컴퓨팅 분야였으나
웹 브라우저에 탑재되면서 인기를 얻었다
JVM

- JavaScript: 웹 프로개래밍 언어
Netscape 사에서 만든 스크립트 언어
Elm, TypesScript 등 다양한 언어로 발전
자바와는 전혀 다른 언어

- Python: 빠른 프로토타이핑 언어
스크립트 언어
동적 언어 추구
다중 패러다임 언어

- Haskell: 순수 함수형 언어
모나드 개념이 탑재되면서 점차 인기
Scala 에 영향을 줌


## 프로그램 동작 원리
### 컴퓨터 구조와 프로그램 동작 원리

#### 컴퓨터 구조
CPU 와 메모리, 저장장치 등이 BUS 로 연결
다양한 입출력 장치도 연결될 수 있다

전원 -> 운영체제가 메모리에 적재 (저장장치 -> 메모리) -> 수행
CPU 는 인출-해석-실행 주기를 반복하여 메모리의 명령어를 실행

#### 기계어
CPU 가 이해하고 수행하는 명령어 (0101)
이진수 형태의 명령어를 사람이 이해하는 것은 난해하다

#### 어셈블리어
기계어에 거의 일대일 대응하는 형태의 기호 언어
CPU 에 종속적 -> 이식성이 거의 없다

#### 고급 프로그래밍 언어
 사람에 가까운 표현으로 프로그램을 나타냄
 특정 기계에 종속정이지 않음
 프로그램을 CPU 가 알아듣는 기계어로 표현해주어야 함

 소스 프로그램: 프로그래머가 작성한 프로그램
 목적 프로그램: 컴퓨터 하드웨어가 수행할 수 있는 플로그램

프로그래머가 작성한 소스 프로그램을 컴파일하여 목적 프로그램으로 바꾼뒤 하드웨어가 수행하거나
소스 프로그램을 인터프리터가 명령어를 한 줄씩 해석하여 하드웨어가 한 줄씩 수행할 수 있다

#### 인터프리터
프로그래밍 언어로 작성된 고수준 명령을 한 줄씩 가져와 해석, 수행하는 프로그램
인터프리터는 CPU 의 인출-해석-실행 주기를 흉내낸다
하나의 가상 기걔처럼 보일 수 있다

#### 컴파일러
프로그램을 CPU 가 수행할 수 있는 형태로 바꾸어 CPU 가 실행
인터프리터가 한줄씩 실행하는 해석 과정을 미리 모두 수행 (효율적)
사용 프로그램은 주로 컴파일 방식으로 번역한 후 판매

#### 하이브리드 
인터프리터 방식과 컴파일러 방식을 조합한 방식
중간 코드까지 작은 컴파일 후 인터프리터를 통해 해석
인터프리터를 가상 기계 (VM) 이라고 부른다
중간 코드는 기계어에 유사하지만 가상 기계가 이해할 수 있는 언어로
기계 종속적이지 않다는 장점이 있고
중간에 컴파일이 한 번 되어있기 떄문에 속도도 빠르다는 이점이 있음
자바 같은 언어가 하이브리드

## 프로그래밍 언어 평가 기준
### 프로그래밍 언어 요구사항
- 표현 풍부성: 프로그래머가 아이디어를 원하는대로 표현할 수 있어야 함
- 유지 보수성: 변화에 쉽게 대응할 수 있어야 한다
- 실행 가능성: 컴퓨터에서 실행할 수 있어야 한다

## 설계 원칙
- 규칙성: 언어의 기능이 잘 조합될 수 있어야 한다 (일반성, 직교성, 일관성)
- 추상화 지원: 실세계의 대상을 추상화하여 나타낼 수 있고 이를 대상으로 연산을 수행할 수 있어야 한다 (데이터 추상화, 제어 추상화, 추상 데이터 타입 정의)
- 복잡도 제어: 복잡한 대상 및 처리 방법을 제어할 수 있어야 한다 (캡슐화, 모듈화)

## 평가 기준
- 작성력
- 가독성
- 신뢰성: 오류 가능성을 줄이는 것
- 직교성: 언어의 기능이 서로 간섭하지 않고 자유롭게 조합될 수 있는지
- 일관성
- 확장성
- 효율성
- 유연성
- 이식성

![Alt text](/Users/swk/Desktop/lumpenop.github.io/assets/img/posts_images/KNOU/PL/standard_table.png)
![Alt text](/Users/swk/Desktop/lumpenop.github.io/assets/img/posts_images/KNOU/PL/conflict_table.png)

서로 상충되는 평가 기준이 있기 떄문에
트레이드 오프 관계인 경우가 있어 완벽한 프로그래밍 언어는 없다

#### 프로그래밍 언어 선택 기준
커뮤니티가 활발한
특정 응용 분야가 존재하는
새로운

각자의 기준에 맞추어 선택한다